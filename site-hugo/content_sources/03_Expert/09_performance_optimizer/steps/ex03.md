```py
"""
Step 3: Add Pagination
- Implement data pagination
- Show only subset of data
- Reduce rendering time
"""

import streamlit as st
import pandas as pd
import numpy as np
import time

st.set_page_config(page_title="Performance Optimizer", page_icon="‚ö°", layout="wide")

st.title("‚ö° Performance Optimizer")

st.markdown("""
### Optimization Techniques Demonstrated:
1. **Caching** - Cache expensive computations
2. **Pagination** ‚ö° - Display data in chunks
3. Column Selection (coming next)
""")

@st.cache_data
def generate_large_dataset(n_rows):
    time.sleep(1)
    return pd.DataFrame(
        np.random.randn(n_rows, 10),
        columns=[f'Col_{i}' for i in range(10)]
    )

# Caching demo
st.subheader("1. Data Caching")

if st.button("Generate Dataset (Cached)"):
    start = time.time()
    df = generate_large_dataset(10000)
    elapsed = time.time() - start
    st.success(f"Generated in {elapsed:.2f}s (subsequent runs will be instant)")
    st.dataframe(df.head(), use_container_width=True)

st.divider()

# STEP 1: Add pagination section
st.subheader("2. Pagination ‚ö°")

st.markdown("""
**Problem**: Displaying thousands of rows slows down the browser.

**Solution**: Show data in pages (e.g., 50 rows at a time).
""")

# STEP 2: Generate large dataset for pagination
total_rows = 10000
df_large = generate_large_dataset(total_rows)

# STEP 3: Add pagination controls
col1, col2 = st.columns([3, 1])

with col1:
    page_size = st.slider(
        "Rows per page",
        min_value=10,
        max_value=100,
        value=50,
        step=10,
        help="Number of rows to display per page"
    )

with col2:
    total_pages = (total_rows + page_size - 1) // page_size  # Ceiling division
    page_number = st.number_input(
        "Page",
        min_value=1,
        max_value=total_pages,
        value=1,
        step=1,
        help=f"Navigate through {total_pages} pages"
    )

# STEP 4: Calculate slice indices
start_idx = (page_number - 1) * page_size
end_idx = start_idx + page_size

# STEP 5: Display only the current page
st.dataframe(df_large.iloc[start_idx:end_idx], use_container_width=True)

# STEP 6: Show pagination info
st.caption(f"Showing rows {start_idx + 1} to {min(end_idx, total_rows)} of {total_rows:,}")

# STEP 7: Add navigation helper
col1, col2, col3 = st.columns([1, 2, 1])

with col1:
    if page_number > 1:
        if st.button("‚¨ÖÔ∏è Previous"):
            st.rerun()

with col2:
    st.write(f"Page {page_number} of {total_pages}")

with col3:
    if page_number < total_pages:
        if st.button("Next ‚û°Ô∏è"):
            st.rerun()

# STEP 8: Show performance comparison
st.divider()

st.subheader("üìä Pagination Performance Impact")

col1, col2 = st.columns(2)

with col1:
    st.write("**Without Pagination:**")
    st.code("""
# Display all 10,000 rows
st.dataframe(df)

# Problems:
# - Browser renders 10,000 rows
# - Slow initial load
# - High memory usage
# - Poor user experience
    """)
    st.error("Rendering time: ~5 seconds ‚ö†Ô∏è")

with col2:
    st.write("**With Pagination:**")
    st.code("""
# Display only 50 rows at a time
start = (page - 1) * 50
end = start + 50
st.dataframe(df[start:end])

# Benefits:
# - Fast rendering
# - Low memory usage
# - Better UX
# - Scalable
    """)
    st.success("Rendering time: <0.1 seconds ‚úÖ")

# STEP 9: Add best practices
with st.expander("üí° Pagination Best Practices"):
    st.markdown("""
    ### When to Use Pagination

    **Use pagination when:**
    - Displaying > 100 rows
    - Data updates frequently
    - Users don't need to see all data at once
    - Optimizing for mobile devices

    ### Implementation Strategies

    #### 1. Simple Slicing (This Example)
    ```python
    page_size = 50
    page = 1
    start = (page - 1) * page_size
    end = start + page_size
    st.dataframe(df[start:end])
    ```

    #### 2. Database-Level Pagination
    ```python
    # Better for very large datasets
    query = f"SELECT * FROM table LIMIT {page_size} OFFSET {start}"
    df = pd.read_sql(query, conn)
    ```

    #### 3. Virtual Scrolling
    - Load data as user scrolls
    - Good for infinite scroll UX
    - More complex to implement

    ### Page Size Guidelines

    - **Mobile**: 10-25 rows
    - **Desktop**: 25-50 rows
    - **Data tables**: 50-100 rows
    - **Heavy data**: 10-25 rows

    ### User Experience Tips

    1. Show total row count
    2. Display current page/total pages
    3. Add previous/next buttons
    4. Allow page size adjustment
    5. Remember page position on reload
    6. Add "jump to page" input
    7. Show loading indicators
    """)

st.divider()
st.caption("Built with Streamlit üéà")

```